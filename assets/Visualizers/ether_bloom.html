<!-- Ether Bloom Viz (Drop-in only) -->
<div id="etherBloomViz" class="eb-viz" aria-label="Ether Bloom visualizer"></div>

<style>
  .eb-viz{
    width:100%;
    aspect-ratio:16/9;
    border-radius:16px;
    overflow:hidden;
    background: radial-gradient(120% 120% at 50% 35%, rgba(120,255,220,.16), rgba(120,120,255,.10) 35%, rgba(0,0,0,.92) 80%);
    position:relative;
    box-shadow: 0 0 0 1px rgba(180,255,240,.10) inset, 0 10px 60px rgba(0,0,0,.55);
  }
  .eb-viz canvas{ width:100%; height:100%; display:block; }
  .eb-hud{
    position:absolute; left:14px; top:12px;
    font: 600 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
    letter-spacing:.14em; text-transform:uppercase;
    color: rgba(200,255,245,.85);
    text-shadow: 0 0 18px rgba(120,255,220,.25);
    user-select:none; pointer-events:none;
  }
  .eb-sub{
    display:block; font-weight:500; letter-spacing:.08em;
    margin-top:6px; color: rgba(200,210,255,.65);
  }
</style>

<script>
(() => {
  const host = document.getElementById("etherBloomViz");
  if(!host) return;

  // Clean re-inject safety
  host.querySelectorAll("canvas").forEach(c=>c.remove());
  host.querySelectorAll(".eb-hud").forEach(h=>h.remove());

  const hud = document.createElement("div");
  hud.className = "eb-hud";
  hud.innerHTML = `ETHER BLOOM<span class="eb-sub">X1NTH • luminous petals / signal pollen</span>`;
  host.appendChild(hud);

  const canvas = document.createElement("canvas");
  host.appendChild(canvas);
  const ctx = canvas.getContext("2d", { alpha: true });

  const DPR = Math.min(2, window.devicePixelRatio || 1);

  function resize(){
    const r = host.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(r.width * DPR));
    canvas.height = Math.max(1, Math.floor(r.height * DPR));
  }
  resize();
  new ResizeObserver(resize).observe(host);

  // Audio source: if a global <audio> exists, try to hook it. Otherwise run in "pulse mode".
  let analyser = null, data = null, useAudio = false;
  try{
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const ac = new AudioCtx();
    const audioEl = document.querySelector("audio");
    if(audioEl){
      const src = ac.createMediaElementSource(audioEl);
      analyser = ac.createAnalyser();
      analyser.fftSize = 2048;
      data = new Uint8Array(analyser.frequencyBinCount);
      src.connect(analyser);
      analyser.connect(ac.destination);
      useAudio = true;

      // Attempt to resume on first user gesture
      const resume = () => ac.resume().catch(()=>{});
      window.addEventListener("pointerdown", resume, { once:true });
      window.addEventListener("keydown", resume, { once:true });
    }
  }catch(e){ /* silent */ }

  // Bloom particles
  const petals = [];
  const maxPetals = 420;

  function rand(min,max){ return min + Math.random()*(max-min); }

  function spawnPetal(centerX, centerY, power){
    if(petals.length > maxPetals) petals.splice(0, petals.length - maxPetals);

    const a = rand(0, Math.PI*2);
    const speed = rand(0.4, 2.2) * (0.6 + power*1.8);
    petals.push({
      x:centerX + Math.cos(a)*rand(0,8)*DPR,
      y:centerY + Math.sin(a)*rand(0,8)*DPR,
      vx:Math.cos(a)*speed*DPR,
      vy:Math.sin(a)*speed*DPR - rand(0.15,0.7)*DPR,
      life: rand(0.7, 1.35),
      age: 0,
      size: rand(1.2, 3.8) * (0.8 + power*1.7) * DPR,
      hue: rand(155, 205) + rand(-10, 10),
      tw: rand(0.8, 1.6),
      spin: rand(-0.035, 0.035),
      rot: rand(0, Math.PI*2),
      drift: rand(0.25, 0.7)
    });
  }

  // Soft vignette
  function vignette(){
    const w = canvas.width, h = canvas.height;
    const g = ctx.createRadialGradient(w*0.5, h*0.48, Math.min(w,h)*0.08, w*0.5, h*0.5, Math.max(w,h)*0.68);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.72)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }

  // Main bloom ring (petal-like lissajous)
  function drawBloom(cx, cy, t, power){
    const w = canvas.width, h = canvas.height;
    const baseR = Math.min(w,h) * 0.16;
    const pulse = 1 + Math.sin(t*2.0) * (0.05 + power*0.14);
    const R = baseR * pulse;

    // Glow
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.lineWidth = (2.0 + power*4.2) * DPR;

    for(let k=0;k<3;k++){
      const alpha = 0.22 - k*0.06;
      ctx.strokeStyle = `rgba(120,255,220,${alpha})`;
      ctx.beginPath();

      const petalsCount = 7; // “bloom” feel
      for(let i=0;i<=420;i++){
        const a = (i/420) * Math.PI*2;
        const petal = Math.sin(petalsCount*a + t*0.9) * (0.25 + power*0.35);
        const wob = Math.sin(a*3 + t*1.7) * (0.05 + power*0.10);
        const r = R * (1 + petal + wob);

        const x = cx + Math.cos(a + t*0.06) * r;
        const y = cy + Math.sin(a) * r * 0.92;

        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.lineWidth *= 1.55;
    }
    ctx.restore();

    // “pollen” dots
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    const dots = 26 + Math.floor(power*34);
    for(let i=0;i<dots;i++){
      const a = (i/dots)*Math.PI*2 + t*0.18;
      const r = R * (0.65 + 0.32*Math.sin(t*1.3 + i));
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r*0.92;
      const s = (1.2 + 2.4*Math.random()) * (0.9 + power) * DPR;

      ctx.fillStyle = `rgba(200,255,245,${0.16 + power*0.25})`;
      ctx.beginPath();
      ctx.arc(x,y,s,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // Echo veil (soft vertical shimmer)
  function drawVeil(t, power){
    const w = canvas.width, h = canvas.height;
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    const lines = 18;
    for(let i=0;i<lines;i++){
      const x = (i/(lines-1))*w;
      const a = 0.02 + power*0.05;
      const sway = Math.sin(t*0.8 + i*0.9) * (8 + power*22) * DPR;

      const grad = ctx.createLinearGradient(x, 0, x + sway, h);
      grad.addColorStop(0, `rgba(140,220,255,0)`);
      grad.addColorStop(0.5, `rgba(140,220,255,${a})`);
      grad.addColorStop(1, `rgba(140,220,255,0)`);

      ctx.fillStyle = grad;
      ctx.fillRect(x-1, 0, 3, h);
    }
    ctx.restore();
  }

  let last = performance.now();
  let t = 0;

  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    t += dt;

    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    // Power from audio or a gentle auto pulse
    let power = 0.28 + 0.18*Math.sin(t*1.1);
    if(useAudio && analyser && data){
      analyser.getByteFrequencyData(data);
      // low-mid energy for “bloom”
      let sum = 0;
      const start = 6, end = Math.min(data.length-1, 90);
      for(let i=start;i<=end;i++) sum += data[i];
      const avg = sum / (end-start+1);
      power = Math.min(1, Math.max(0, (avg/255)));
    }

    const cx = w*0.5;
    const cy = h*0.52;

    // Background haze
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(0,0,w,h);

    drawVeil(t, power);
    drawBloom(cx, cy, t, power);

    // Spawn petals on “peaks”
    const spawnRate = (useAudio ? (6 + power*22) : (8 + power*10));
    const spawns = Math.floor(spawnRate);
    for(let i=0;i<spawns;i++) spawnPetal(cx, cy, power);

    // Update + draw petals
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for(let i=petals.length-1;i>=0;i--){
      const p = petals[i];
      p.age += dt;
      if(p.age > p.life){ petals.splice(i,1); continue; }

      // motion with gentle curl
      p.vx += Math.sin(t*1.4 + i*0.03) * p.drift * 0.6 * DPR * dt;
      p.vy += Math.cos(t*1.1 + i*0.02) * p.drift * 0.35 * DPR * dt;

      p.x += p.vx;
      p.y += p.vy;

      p.rot += p.spin;

      const k = 1 - (p.age/p.life);
      const alpha = (0.26 + power*0.30) * (k*k);

      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);

      // petal: tiny teardrop
      const s = p.size * (0.6 + k*0.8);
      const grad = ctx.createRadialGradient(0,0,0, 0,0,s*2.2);
      grad.addColorStop(0, `hsla(${p.hue}, 95%, 72%, ${alpha})`);
      grad.addColorStop(1, `hsla(${p.hue+30}, 95%, 58%, 0)`);

      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(0, -s*1.25);
      ctx.quadraticCurveTo(s*0.9, -s*0.2, 0, s*1.3);
      ctx.quadraticCurveTo(-s*0.9, -s*0.2, 0, -s*1.25);
      ctx.fill();

      ctx.setTransform(1,0,0,1,0,0);
    }
    ctx.restore();

    vignette();
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
})();
</script>